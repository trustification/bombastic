use std::rc::Rc;

use patternfly_yew::{
    next::{
        use_table_data, Cell, CellContext, ColumnWidth, MemoizedTableModel, Table, TableColumn, TableEntryRenderer,
        TableHeader, Toolbar, ToolbarContent, UseTableData,
    },
    prelude::*,
};
use spog_model::prelude::*;
use yew::prelude::*;
use yew_more_hooks::hooks::{use_async_with_cloned_deps, UseAsyncHandleDeps};
use yew_nested_router::components::Link;

use crate::{
    backend::{SearchOptions, VexService},
    components::common::SafeHtml,
    components::cvss::CvssScore,
    hooks::use_backend,
    pages::AppRoute,
    utils::cvss::Cvss,
    utils::last_weeks_date,
};

#[derive(PartialEq, Properties)]
pub struct VulnerabilitySearchProperties {
    pub callback: Callback<UseAsyncHandleDeps<SearchResult<Rc<Vec<VulnSummary>>>, String>>,

    pub query: Option<String>,

    #[prop_or_default]
    pub toolbar_items: ChildrenWithProps<ToolbarItem>,
}

#[function_component(VulnerabilitySearch)]
pub fn vulnerability_search(props: &VulnerabilitySearchProperties) -> Html {
    let backend = use_backend();

    let service = use_memo(|backend| VexService::new((**backend).clone()), backend.clone());

    let offset = use_state_eq(|| 0);
    let limit = use_state_eq(|| 10);

    // Default is vulnerabilities past weeks
    let default_query = format!("release:>{}", last_weeks_date());

    // the active query
    let state = use_state_eq(|| {
        // initialize with the state from history, or with a reasonable default
        props.query.clone().unwrap_or_else(|| {
            gloo_utils::history()
                .state()
                .ok()
                .and_then(|state| state.as_string())
                .unwrap_or(default_query)
        })
    });

    let search = {
        let service = service.clone();
        use_async_with_cloned_deps(
            move |(state, offset, limit)| async move {
                service
                    .search_vulnerabilities(
                        &state,
                        &SearchOptions {
                            offset: Some(offset),
                            limit: Some(limit),
                        },
                    )
                    .await
                    .map(|result| result.map(Rc::new))
                    .map_err(|err| err.to_string())
            },
            ((*state).clone(), *offset, *limit),
        )
    };

    use_effect_with_deps(
        |(callback, search)| {
            callback.emit(search.clone());
        },
        (props.callback.clone(), search.clone()),
    );

    // the current value in the text input field
    let text = use_state_eq(|| (*state).clone());

    let onclear = {
        let text = text.clone();
        Callback::from(move |_| {
            text.set(String::new());
        })
    };
    let onset = {
        let state = state.clone();
        let text = text.clone();
        Callback::from(move |()| {
            state.set((*text).clone());
        })
    };

    use_effect_with_deps(
        |query| {
            // store changes to the state in the current history
            let _ = gloo_utils::history().replace_state(&query.into(), "");
        },
        (*state).clone(),
    );

    // pagination

    let total = search.data().and_then(|d| d.total);
    let onlimit = {
        let limit = limit.clone();
        Callback::from(move |n| {
            limit.set(n);
        })
    };
    let onnavigation = {
        if let Some(total) = total {
            let offset = offset.clone();

            let limit = limit.clone();
            Callback::from(move |nav| {
                let o = match nav {
                    Navigation::First => 0,
                    Navigation::Last => total - *limit,
                    Navigation::Next => *offset + *limit,
                    Navigation::Previous => *offset - *limit,
                    Navigation::Page(n) => *limit * n - 1,
                };
                offset.set(o);
            })
        } else {
            Callback::default()
        }
    };

    let hidden = text.is_empty();

    // render
    html!(
        <>
            <Toolbar>
                <ToolbarContent>
                    <ToolbarGroup>
                        <ToolbarItem r#type={ToolbarItemType::SearchFilter} width={["600px".to_string()]}>
                            <Form onsubmit={onset.reform(|_|())}>
                                // needed to trigger submit when pressing enter in the search field
                                <input type="submit" hidden=true formmethod="dialog" />
                                <InputGroup>
                                    <TextInputGroup>
                                        <TextInputGroupMain
                                            icon={Icon::Search}
                                            placeholder="Search"
                                            value={(*text).clone()}
                                            oninput={ Callback::from(move |data| text.set(data)) }
                                        />
                                        <TextInputGroupUtilities>
                                            <div hidden={hidden}>
                                                <Button icon={Icon::Times} variant={ButtonVariant::None} onclick={onclear} />
                                            </div>
                                        </TextInputGroupUtilities>
                                        <Button icon={Icon::ArrowRight} variant={ButtonVariant::Control} onclick={onset.reform(|_|())} />
                                    </TextInputGroup>
                                </InputGroup>
                            </Form>
                        </ToolbarItem>
                    </ToolbarGroup>

                    { for props.toolbar_items.iter() }

                    <ToolbarItem r#type={ToolbarItemType::Pagination}>
                        <Pagination
                            total_entries={total}
                            selected_choice={*limit}
                            offset={*offset}
                            entries_per_page_choices={vec![10, 25, 50]}
                            {onnavigation}
                            {onlimit}
                        >
                        </Pagination>
                    </ToolbarItem>

                </ToolbarContent>
                // <ToolbarContent> { for filters.into_iter() } </ToolbarContent>
            </Toolbar>

        </>
    )
}

#[derive(Debug, Properties)]
pub struct VulnResultProperties {
    pub result: SearchResult<Rc<Vec<VulnSummary>>>,
}

impl PartialEq for VulnResultProperties {
    fn eq(&self, other: &Self) -> bool {
        Rc::ptr_eq(&self.result, &other.result)
    }
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub enum Column {
    Cve,
    Title,
    Released,
    Cvss,
}

impl TableEntryRenderer<Column> for VulnSummary {
    fn render_cell(&self, context: &CellContext<'_, Column>) -> Cell {
        match context.column {
            Column::Cve => html!(&self.id).into(),
            Column::Title => html!(&self.title).into(),
            Column::Released => {
                let format = time::macros::format_description!("[year]-[month]-[day]");
                let s = if let Ok(s) = self.release.format(format) {
                    s.to_string()
                } else {
                    self.release.to_string()
                };
                html!(s).into()
            }
            Column::Cvss => {
                if let Some(cvss) = self.cvss {
                    let cvss = Cvss {
                        score: cvss as f32,
                        status: String::new(),
                    };
                    html!(<CvssScore {cvss}/>).into()
                } else {
                    html!({ "N/A" }).into()
                }
            }
        }
    }

    fn render_details(&self) -> Vec<Span> {
        let html = html!(<VulnDetails vuln={Rc::new(self.clone())} />);
        vec![Span::max(html)]
    }

    fn is_full_width_details(&self) -> Option<bool> {
        Some(true)
    }
}

#[function_component(VulnerabilityResult)]
pub fn vulnerability_result(props: &VulnResultProperties) -> Html {
    let (entries, onexpand) = use_table_data(MemoizedTableModel::new(props.result.result.clone()));

    let header = html_nested! {
        <TableHeader<Column>>
            <TableColumn<Column> label="CVE" index={Column::Cve} width={ColumnWidth::Percent(10)}/>
            <TableColumn<Column> label="Title" index={Column::Title} width={ColumnWidth::Percent(50)}/>
            <TableColumn<Column> label="Score" index={Column::Cvss} width={ColumnWidth::Percent(20)}/>
            <TableColumn<Column> label="Released" index={Column::Released} width={ColumnWidth::Percent(20)}/>
        </TableHeader<Column>>
    };

    html!(
        <Table<Column, UseTableData<Column, MemoizedTableModel<VulnSummary>>>
            mode={TableMode::CompactExpandable}
            {header}
            {entries}
            {onexpand}
        />
    )
}

#[derive(Clone, Properties)]
pub struct VulnDetailsProps {
    pub vuln: Rc<VulnSummary>,
}

impl PartialEq for VulnDetailsProps {
    fn eq(&self, other: &Self) -> bool {
        Rc::ptr_eq(&self.vuln, &other.vuln)
    }
}

#[function_component(VulnDetails)]
pub fn vuln_details(props: &VulnDetailsProps) -> Html {
    let summary = use_memo(|props| props.vuln.clone(), props.clone());

    let advisories: Vec<Html> = summary
        .advisories
        .iter()
        .map(|a| {
            html!(
                <Link<AppRoute> target={AppRoute::Advisory { query: format!("id:{}", a) }}>{a}</Link<AppRoute>>
            )
        })
        .collect::<Vec<Html>>();
    let snippet = summary.snippet.clone();
    html!(
        <Panel>
            <PanelMain>
            <PanelMainBody>
            <SafeHtml html={snippet} />
            </PanelMainBody>
            </PanelMain>
            <PanelFooter>
            <h3>{"Related Advisories"}</h3>
            <List r#type={ListType::Inline}>
            {advisories}
            </List>
            </PanelFooter>
        </Panel>
    )
}
