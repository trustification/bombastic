mod lookup;

use crate::backend::{data::PackageRef, VulnerabilityService};
use crate::components::{
    common::PageHeading, cvss::CvssScore, error::Error, vexination::VexinationSearch, vulns::VulnerabilityResult,
};
use crate::hooks::use_backend;
use crate::pages::AppRoute;
use csaf::Csaf;
use packageurl::PackageUrl;
use patternfly_yew::{
    next::{Card, CardBody, CardDivider},
    prelude::*,
};
use spog_model::prelude::*;
use std::rc::Rc;
use std::str::FromStr;
use yew::prelude::*;
use yew_more_hooks::hooks::r#async::*;
use yew_nested_router::components::Link;

#[derive(Clone, Debug, PartialEq, Eq, Properties)]
pub struct VulnerabilityProps {
    #[prop_or_default]
    pub cve: String,
}

#[function_component(Vulnerability)]
pub fn vulnerability(props: &VulnerabilityProps) -> Html {
    let search = use_state_eq(UseAsyncState::default);
    let callback = {
        let search = search.clone();
        Callback::from(move |state: UseAsyncHandleDeps<SearchResult<Rc<Vec<Csaf>>>, String>| {
            search.set((*state).clone());
        })
    };

    let backdrop = use_backdrop();

    let by_cve_id = {
        let onlookup = Callback::from(move |_| {
            if let Some(backdrop) = &backdrop {
                backdrop.open(html!(<lookup::LookupVulnerabilityModal/>));
            }
        });

        html_nested!(
            <ToolbarItem>
                <Button label="By CVE ID" variant={ButtonVariant::Secondary} onclick={onlookup}/>
            </ToolbarItem>
        )
    };

    html!(
        <>
            <PageHeading subtitle="Get detailed vulnerability information">{"Vulnerabilities"}</PageHeading>

            // We need to set the main section to fill, as we have a footer section
            <PageSection variant={PageSectionVariant::Default} fill={PageSectionFill::Fill}>
                if !props.cve.is_empty() {
                    <VulnerabilityInformation cve={props.cve.clone()} />
                } else {
                    <VexinationSearch {callback}
                        toolbar_items={vec![by_cve_id]}
                    />
                    {
                        match &*search {
                            UseAsyncState::Pending | UseAsyncState::Processing => { html!( <Bullseye><Spinner/></Bullseye> ) }
                            UseAsyncState::Ready(Ok(result)) if result.is_empty() => {
                                html!(
                                    <Bullseye>
                                        <EmptyState
                                            title="No results"
                                            icon={Icon::Search}
                                        >
                                            { "Try a different search expression." }
                                        </EmptyState>
                                    </Bullseye>
                                )
                            },
                            UseAsyncState::Ready(Ok(result)) => {
                                let result = result.clone();
                                html!(<VulnerabilityResult {result} />)
                            },
                            UseAsyncState::Ready(Err(err)) => html!(
                                <Error err={err.clone()}/>
                            ),
                        }
                    }
                }
            </PageSection>
        </>
    )
}

#[derive(Clone, Debug, PartialEq, Properties)]
pub struct VulnerabilityInformationProperties {
    cve: String,
}

#[function_component(VulnerabilityInformation)]
fn vulnerability_information(props: &VulnerabilityInformationProperties) -> Html {
    let backend = use_backend();

    let fetch = use_async_with_cloned_deps(
        |cve| async move { VulnerabilityService::new((*backend).clone()).lookup(&cve).await },
        props.cve.clone(),
    );

    match &*fetch {
        UseAsyncState::Pending | UseAsyncState::Processing => html!(<Spinner/>),
        UseAsyncState::Ready(Ok(Some(data))) => html!(<VulnerabilityDetails vulnerability={Rc::new(data.clone())}/>),
        UseAsyncState::Ready(Ok(None)) => {
            html!(
                <EmptyState
                    full_height=true
                    title="Not found"
                    icon={Icon::Search}
                >
                    { "The requested vulnerability could not be found." }
                </EmptyState>
            )
        }
        UseAsyncState::Ready(Err(err)) => html!(<>{"Failed to load: "} { err } </>),
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Properties)]
pub struct VulnerabilityDetailsProperties {
    pub vulnerability: Rc<crate::backend::data::Vulnerability>,
}

#[function_component(VulnerabilityDetails)]
fn vulnerability_details(props: &VulnerabilityDetailsProperties) -> Html {
    html!(
        <Grid gutter=true>
            <GridItem cols={[9.lg(), 12.all()]}>
                <Card
                    title={html!(<Title size={Size::XXXLarge}>{&props.vulnerability.cve}</Title>)}
                >
                    <CardBody>
                        <Content> {props.vulnerability.summary.clone()} </Content>
                    </CardBody>
                </Card>
            </GridItem>

            <GridItem cols={[3.lg(), 12.all()]}>
                <Stack gutter=true>
                    <StackItem>
                        <Overview vulnerability={props.vulnerability.clone()} />
                    </StackItem>
                    <StackItem>
                        <AffectedPackages packages={props.vulnerability.packages.clone()} />
                    </StackItem>
                </Stack>
            </GridItem>
        </Grid>
    )
}

#[derive(Clone, Debug, PartialEq, Eq, Properties)]
struct OverviewProperties {
    pub vulnerability: Rc<crate::backend::data::Vulnerability>,
}

#[function_component(Overview)]
fn overview(props: &OverviewProperties) -> Html {
    html!(
        <Card>
            <CardBody>
                <DescriptionList mode={DescriptionListMode::Horizontal}>
                    <DescriptionGroup term="CVSS v3">
                        {
                            match &props.vulnerability.cvss3 {
                                Some(cvss) => html!(<>
                                    <CvssScore {cvss}/> {" "} <Label label={cvss.status.clone()} />
                                </>),
                                None => html!(<i>{"None"}</i>),
                            }
                        }
                    </DescriptionGroup>

                    if let Some(date) = props.vulnerability.date {
                        <DescriptionGroup term="Date">
                            { date.to_rfc3339() }
                        </DescriptionGroup>
                    }
                </DescriptionList>
            </CardBody>
            <CardDivider/>
            <CardBody>
                <a target="_blank" href={props.vulnerability.advisory.clone()}> {"Advisory "} { Icon::ExternalLinkAlt } </a>
            </CardBody>
        </Card>
    )
}

#[derive(Clone, Debug, PartialEq, Eq, Properties)]
pub struct AffectPackagesProperties {
    pub packages: Vec<PackageRef>,
}

#[function_component(AffectedPackages)]
fn affected_packages(props: &AffectPackagesProperties) -> Html {
    let title = html!("Affected Packages");
    html!(
        <Card {title}>
            <CardBody>
                <List r#type={ListType::Plain}>
                    {
                        for props.packages.iter().map(|pkg| {
                            html!(<AffectedPackage pkg={pkg.clone()}/>)
                        })
                    }
                </List>
            </CardBody>
        </Card>
    )
}

#[derive(Clone, Debug, PartialEq, Eq, Properties)]
pub struct AffectedPackageProperties {
    pkg: PackageRef,
}

#[function_component(AffectedPackage)]
fn affected_package(props: &AffectedPackageProperties) -> Html {
    let purl = PackageUrl::from_str(props.pkg.purl.as_str()).ok();
    html!(
        if let Some(purl) = purl {
            <Link<AppRoute> target={AppRoute::Package{package: props.pkg.purl.clone()}}>
                <Label label={purl.ty().to_owned()}/>
                {props.pkg.purl.clone()}
            </Link<AppRoute>>
        }
    )
}
