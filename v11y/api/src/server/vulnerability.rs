use actix_web::{error::ResponseError, get, post, web, HttpResponse, Responder};

use v11y_client::Vulnerability;

use crate::db::DbError;
use crate::server::Error;
use crate::SharedState;

impl ResponseError for DbError {}

/// Record vulnerability information
#[utoipa::path(
    responses(
        (status = 200, description = "Successfully ingested"),
        (status = BAD_REQUEST, description = "Missing valid id"),
    ),
)]
#[post("/vulnerability")]
pub(crate) async fn ingest_vulnerability(
    state: web::Data<SharedState>,
    vuln: web::Json<Vulnerability>,
) -> actix_web::Result<impl Responder> {
    state.db.ingest(&vuln).await.map_err(|_| Error::Db)?;
    Ok(HttpResponse::Ok().finish())
}

/// Retrieve vulnerability information
#[utoipa::path(
    responses(
        (status = 200, description = "Successfully retrieved"),
        (status = BAD_REQUEST, description = "Missing valid id"),
    ),
)]
#[get("/vulnerability/{id}")]
pub(crate) async fn get(state: web::Data<SharedState>, id: web::Path<String>) -> actix_web::Result<impl Responder> {
    let vuln = state.db.get(&id, None).await?;
    Ok(HttpResponse::Ok().json(vuln))
}

#[cfg(test)]
mod test {
    use crate::server::config;
    use crate::{AppState, SharedState};
    use actix_web::{test, test::TestRequest, web, App};
    use v11y_client::Vulnerability;

    #[actix_web::test]
    async fn get_none() -> Result<(), anyhow::Error> {
        let state = SharedState::new(AppState::new().await?);

        let app = test::init_service(
            App::new()
                .app_data(web::Data::new(state.clone()))
                .configure(|cfg| config(cfg, None, None)),
        )
        .await;

        let request = TestRequest::get().uri("/api/v1/vulnerability/CVE-none").to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(0, vulns.len());

        Ok(())
    }

    #[actix_web::test]
    async fn get_one() -> Result<(), anyhow::Error> {
        let state = SharedState::new(AppState::new().await?);

        let vuln = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln).await?;

        let app = test::init_service(
            App::new()
                .app_data(web::Data::new(state.clone()))
                .configure(|cfg| config(cfg, None, None)),
        )
        .await;

        let request = TestRequest::get()
            .uri("/api/v1/vulnerability/CVE-test-one")
            .to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(1, vulns.len());

        let vuln_actual = &vulns[0];

        assert_eq!(&vuln, vuln_actual);

        Ok(())
    }

    #[actix_web::test]
    async fn get_several() -> Result<(), anyhow::Error> {
        let state = SharedState::new(AppState::new().await?);

        let vuln_a = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_a).await?;

        let vuln_b = Vulnerability {
            origin: "other-test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_b).await?;

        let vuln_c = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-two".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_c).await?;

        let app = test::init_service(
            App::new()
                .app_data(web::Data::new(state.clone()))
                .configure(|cfg| config(cfg, None, None)),
        )
        .await;

        let request = TestRequest::get()
            .uri("/api/v1/vulnerability/CVE-test-one")
            .to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(2, vulns.len());

        assert!(vulns.contains(&vuln_a));
        assert!(vulns.contains(&vuln_b));

        Ok(())
    }
}
