use actix_web::body::BoxBody;
use actix_web::{error::ResponseError, get, web, HttpResponse, Responder};
use trustification_auth::authenticator::user::UserInformation;
use trustification_auth::authorizer::Authorizer;
use trustification_auth::Permission;
use trustification_common::error::ErrorInformation;
use trustification_storage::S3Path;
use v11y_model::Vulnerability;

use crate::db::DbError;
use crate::server::Error;
use crate::AppState;

impl ResponseError for DbError {}

#[derive(Debug, thiserror::Error)]
pub enum CveError {
    #[error("storage error: {0}")]
    Storage(#[from] trustification_storage::Error),
}

impl ResponseError for CveError {
    fn error_response(&self) -> HttpResponse<BoxBody> {
        match self {
            Self::Storage(trustification_storage::Error::NotFound) => HttpResponse::NotFound().finish(),
            err => HttpResponse::InternalServerError().json(ErrorInformation {
                error: "InternalError".to_string(),
                message: "Internal error".to_string(),
                details: err.to_string(),
            }),
        }
    }
}

/// Record vulnerability information
#[utoipa::path(post, path = "/vulnerability",
    responses(
        (status = 200, description = "Successfully ingested"),
        (status = BAD_REQUEST, description = "Missing valid id"),
    ),
)]
pub(crate) async fn ingest_vulnerability(
    state: web::Data<AppState>,
    vuln: web::Json<Vulnerability>,
    authorizer: web::Data<Authorizer>,
    user: UserInformation,
) -> actix_web::Result<impl Responder> {
    authorizer.require(&user, Permission::IngestVulnerability)?;

    log::info!("Ingest: {:#?}", &vuln.0);

    state.db.ingest(&vuln).await.map_err(|_| Error::Db)?;
    Ok(HttpResponse::Ok().finish())
}

/// Retrieve vulnerability information
#[utoipa::path(
    responses(
        (status = 200, description = "Successfully retrieved"),
        (status = BAD_REQUEST, description = "Missing valid id"),
    ),
)]
#[get("/cve/{id}")]
pub(crate) async fn get_cve(state: web::Data<AppState>, id: web::Path<String>) -> Result<impl Responder, CveError> {
    let path = S3Path::from_key(&id.to_uppercase());

    let cve = state.storage.get_decoded_stream(&path).await?;

    Ok(HttpResponse::Ok().streaming(cve))
}

/// Retrieve vulnerability information
#[utoipa::path(
    responses(
        (status = 200, description = "Successfully retrieved"),
        (status = BAD_REQUEST, description = "Missing valid id"),
    ),
)]
#[get("/vulnerability/{id}")]
pub(crate) async fn get(state: web::Data<AppState>, id: web::Path<String>) -> actix_web::Result<impl Responder> {
    let vuln = state.db.get(&id, None).await?;
    Ok(HttpResponse::Ok().json(vuln))
}

/*
/// Retrieve vulnerability information by alias
#[utoipa::path(
    responses(
        (status = 200, description = "Successfully retrieved"),
        (status = BAD_REQUEST, description = "Missing valid alias"),
    ),
)]
#[get("/vulnerability/by-alias/{alias}")]
pub(crate) async fn get_by_alias(
    state: web::Data<AppState>,
    alias: web::Path<String>,
) -> actix_web::Result<impl Responder> {
    let vuln = state.db.get(GetBy::alias(&*alias), None).await?;
    Ok(HttpResponse::Ok().json(vuln))
}

 */

#[cfg(test)]
mod test {
    use crate::server::config;
    use crate::AppState;
    use actix_web::{test, test::TestRequest, web, App};
    use prometheus::Registry;
    use std::sync::Arc;
    use tempdir::TempDir;
    use trustification_index::IndexStore;
    use trustification_storage::{Storage, StorageConfig};
    use v11y_model::Vulnerability;

    async fn app_state() -> anyhow::Result<Arc<AppState>> {
        let base = TempDir::new("v11y")?;
        let storage = Storage::new(StorageConfig::default(), &Registry::new())?;
        let index = IndexStore::new_in_memory(v11y_index::Index::new())?;
        Ok(Arc::new(AppState::new(base, storage, index).await?))
    }

    #[ignore = "No substitute for Storage"]
    #[actix_web::test]
    async fn get_none() -> Result<(), anyhow::Error> {
        let state = app_state().await?;

        let app = test::init_service(
            App::new()
                .app_data(web::Data::from(state.clone()))
                .configure(|cfg| config(cfg, None, None, 64 * 1024 * 104)),
        )
        .await;

        let request = TestRequest::get().uri("/api/v1/vulnerability/CVE-none").to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(0, vulns.len());

        Ok(())
    }

    #[ignore = "No substitute for Storage"]
    #[actix_web::test]
    async fn get_one() -> Result<(), anyhow::Error> {
        let state = app_state().await?;

        let vuln = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln).await?;

        let app = test::init_service(
            App::new()
                .app_data(web::Data::from(state.clone()))
                .configure(|cfg| config(cfg, None, None, 64 * 1024 * 104)),
        )
        .await;

        let request = TestRequest::get()
            .uri("/api/v1/vulnerability/CVE-test-one")
            .to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(1, vulns.len());

        let vuln_actual = &vulns[0];

        assert_eq!(&vuln, vuln_actual);

        Ok(())
    }

    #[ignore = "No substitute for Storage"]
    #[actix_web::test]
    async fn get_several() -> Result<(), anyhow::Error> {
        let state = app_state().await?;

        let vuln_a = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_a).await?;

        let vuln_b = Vulnerability {
            origin: "other-test-origin".to_string(),
            id: "CVE-test-one".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_b).await?;

        let vuln_c = Vulnerability {
            origin: "test-origin".to_string(),
            id: "CVE-test-two".to_string(),
            modified: Default::default(),
            published: Default::default(),
            withdrawn: None,
            summary: "Test summary".to_string(),
            details: "Test details".to_string(),
            aliases: vec!["CVE-NVD-EIEI0".to_string()],
            affected: vec![],
            severities: vec![],
            related: vec![],
            references: vec![],
        };

        state.db.ingest(&vuln_c).await?;

        let app = test::init_service(
            App::new()
                .app_data(web::Data::from(state.clone()))
                .configure(|cfg| config(cfg, None, None, 64 * 1024 * 104)),
        )
        .await;

        let request = TestRequest::get()
            .uri("/api/v1/vulnerability/CVE-test-one")
            .to_request();

        let vulns: Vec<Vulnerability> = test::call_and_read_body_json(&app, request).await;
        assert_eq!(2, vulns.len());

        assert!(vulns.contains(&vuln_a));
        assert!(vulns.contains(&vuln_b));

        Ok(())
    }
}
